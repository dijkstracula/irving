COMMENT = _{ !SOI ~ "#" ~ !"lang " ~ (!"\n" ~ ANY)* }

// Expressions

ident =  { symbol ~ ("[" ~ ident ~ ("," ~ ident)* ~ "]")? }
    //dot_ident =  { symbol ~ ("." ~ ident)+ } // TODO: subsumed by expr
    //num_ident = { number } //TODO: unclear if we'll ever need this.

// https://pest.rs/book/precedence.html
simple_expr         =  { unary_expr ~ (bin_op ~ unary_expr)* }
    unary_expr      =  { prefix_op? ~ primary }
        prefix_op   = _{ MINUS | NOT }
        bin_op      = _{ PLUS | MINUS | TIMES | DIV |
                         LT | LE | GT | GE | EQ| NEQ |
                         AND | OR | IFF | ISA | DOT }
    primary         = _{ symbol | number | "(" ~ simple_expr ~ ")" }
    // TODO: I don't know what the right thing to do with idents are:
    // they should be where "symbol" is used in the "primary" rule, but
    // that requires bouncing in and out of the Pratt parser.

var = { symbol | (symbol ~ ":" ~ symbol)}

//TODO: contemplate renamining this as just "fnapp"?
expr = { simple_expr ~ fnapp_args? }
fnapp_args = { "(" ~ (expr ~ ("," ~ expr)* )? ~ ")" }

// Decls


param     = { symbol ~ ":" ~ symbol }
paramlist = { param  ~ ("," ~ param)* }
decl_ret   = { "returns" ~ "(" ~ param ~ ")" } //TODO: needs to be a paramlist

decl_sig =  { symbol ~ ("(" ~ paramlist ~ ")")? }

decl_block = { "{" ~ decl* ~ ";"? ~ "}" }

include_decl      = { INCLUDE ~ symbol }
var_decl          = { VAR ~ symbol ~ (":" ~ symbol)? }

init_decl         = { INIT ~ symbol }
after_decl        = { AFTER ~ symbol }
before_decl       = { BEFORE ~ symbol }

function_decl     = { FUNCTION ~ decl_sig ~ ":" ~ symbol }
relation_decl     = { RELATION ~ decl_sig }

module_decl       = { MODULE ~ decl_sig ~ "=" ~ decl_block }
object_decl       = { OBJECT ~ decl_sig ~ "=" ~ decl_block }
extract_decl      = { EXTRACT ~ decl_sig ~ "=" ~ decl_block }
action_decl       = { ACTION ~ decl_sig ~ decl_ret? ~ ("=" ~ decl_block)? }
export_decl       = { EXPORT ~ symbol }

type_decl         = { TYPE ~ symbol ~ ("of" ~ symbol)?} //superclass might have to be more than a symbol

// TODO: not sure exactly about these ones yet.
header_decl       = { HEADER ~ symbol }
interpret_decl    = { INTERPRET ~ symbol }
instantiate_decl  = { INSTANTIATE ~ symbol }
instance_decl     = { INSTANCE ~ decl_sig }
autoinstance_decl = { AUTOINSTANCE ~ decl_sig }
import_decl       = { IMPORT ~ symbol }

decl = {
      action_decl
    | function_decl
    | relation_decl
    | include_decl
    | var_decl
    | header_decl
    | interpret_decl
    | module_decl
    | instantiate_decl
    | object_decl
    | instance_decl
    | autoinstance_decl
    | import_decl
    | export_decl
    | init_decl
    | after_decl
    | before_decl
    | extract_decl
    | type_decl
    | stmt
}

// Actions

assign_action = { (param | expr) ~ ":=" ~ expr} //TODO

action = {
    assign_action
}

actions = { action ~ (";" ~ action)* }

// Statements

stmt_block = { "{" ~ stmt* ~ ";"? ~ "}" }

return_stmt = { "return" ~ expr}
if_stmt     = { "if"    ~ expr ~ stmt_block ~ ("else" ~ stmt_block)? }
while_stmt  = { "while" ~ expr ~ stmt_block }

stmt = {
      if_stmt
    | return_stmt
    | while_stmt
    | var_decl // or something??  Feels weird to mix a decl into a stmt like this.
    | actions
}

// Toplevels 
hashlang    = _{ SOI ~ "#lang" ~ langver }
    langver = ${ "ivy" ~ number ~ ("." ~ number)? }

prog = {
      hashlang
    ~ decl*
    ~ EOI
}
