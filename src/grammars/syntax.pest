COMMENT = _{ !SOI ~ "#" ~ !"lang " ~ (!"\n" ~ ANY)* }

// Expressions

// A param is a token with an optional type annotation.  These are for things
// like quantifier and fn argument lists.
param = { symbol ~ ( ":" ~ symbol)? }
paramlist = { param ~ ("," ~ param)* }

ident = { symbol ~ ("." ~ symbol)* }

// A term is a fully-qualified identifier with an optional type annotation.
term = { ident ~ ( ":" ~ ident)? }
termlist = { term ~ ("," ~ term)* }

// https://pest.rs/book/precedence.html
expr =  { 
      exists
    | forall 
    | simple_expr
}
exists          =  { "exists" ~ paramlist ~ "." ~ expr }
forall          =  { "forall" ~ paramlist ~ "." ~ expr }

simple_expr     =  { atom ~ (infix_op ~ atom)* }
atom            = _{ prefix_op? ~ primary ~ postfix_op? }
    prefix_op   = _{ UMINUS | NOT }
    infix_op    = _{ IFF | ARROW | 
                     PLUS | MINUS | TIMES | DIV |
                     LT | LE | GT | GE | EQ | NEQ |
                     AND | OR | ISA }
    postfix_op  = _{ fnapp_args }
primary         = _{ term | number | boollit | "(" ~ simple_expr ~ ")" }

//TODO: contemplate renamining this as just "fnapp"?
//TODO: square bracket notation too
fnapp_args = { "(" ~ (expr ~ ("," ~ expr)* )? ~ ")" }


// Decls

decl_ret   = { "returns" ~ "(" ~ param ~ ")" } //TODO: needs to be a paramlist

decl_sig =  { ident ~ ("(" ~ paramlist ~ ")")? }

decl_block = { "{" ~ decl* ~ ";"? ~ "}" }

include_decl      = { INCLUDE ~ symbol }
var_decl          = { VAR ~ term }

after_decl        = { AFTER  ~ (decl_sig ~ decl_ret?)? ~ decl_block }
before_decl       = { BEFORE ~ (decl_sig ~ decl_ret?)? ~ decl_block }

axiom_decl        = { AXIOM ~ expr }

function_decl     = { FUNCTION ~ decl_sig ~ ":" ~ symbol }
relation_decl     = { RELATION ~ decl_sig }

module_decl       = { MODULE ~ decl_sig ~ "=" ~ decl_block }
object_decl       = { OBJECT ~ decl_sig ~ "=" ~ decl_block }
extract_decl      = { EXTRACT ~ decl_sig ~ "=" ~ decl_block }
action_decl       = { ACTION ~ decl_sig ~ decl_ret? ~ ("=" ~ decl_block)? }
export_decl       = { EXPORT ~ (ident | action_decl) }

instance_decl     = { INSTANCE ~ ident ~ ":" ~ decl_sig }

type_decl         = { TYPE ~ symbol ~ ("of" ~ symbol)?} //superclass might have to be more than a symbol

invariant_decl    = { INVARIANT ~ expr }

// TODO: not sure exactly about these ones yet.
header_decl       = { HEADER ~ symbol }
interpret_decl    = { INTERPRET ~ symbol }
instantiate_decl  = { INSTANTIATE ~ symbol }
autoinstance_decl = { AUTOINSTANCE ~ decl_sig }
import_decl       = { IMPORT ~ symbol }

decl = {
      action_decl
    | axiom_decl
    | function_decl
    | relation_decl
    | include_decl
    | var_decl
    | header_decl
    | interpret_decl
    | invariant_decl
    | module_decl
    | instantiate_decl
    | object_decl
    | instance_decl
    | autoinstance_decl
    | import_decl
    | export_decl
    | after_decl
    | before_decl
    | extract_decl
    | type_decl
    | (stmt ~ (";" ~ stmt)* )
}

// Actions

assign_action = { (var_decl | expr) ~ ":=" ~ expr} //TODO
assert_action = { ASSERT ~ expr}
assume_action = { ASSUME ~ expr}
ensure_action = { ENSURE ~ expr}
requires_action = { REQUIRE ~ expr}

action = {
      assign_action
    | assert_action
    | assume_action
    | ensure_action
    | requires_action
}

actions = { action ~ (";" ~ action)* }

// Statements

stmt_block = { "{" ~ stmt* ~ ";"? ~ "}" }

return_stmt = { "return" ~ expr}
if_stmt     = { "if"    ~ expr ~ stmt_block ~ ("else" ~ stmt_block)? }
while_stmt  = { "while" ~ expr ~ stmt_block }

stmt = {
      actions
    | if_stmt
    | return_stmt
    | while_stmt
    | var_decl // or something??  Feels weird to mix a decl into a stmt like this.
}

// Toplevels 
hashlang    = _{ SOI ~ "#lang" ~ langver }
    langver = ${ "ivy" ~ number ~ ("." ~ number)? }

prog = {
      hashlang
    ~ decl*
    ~ EOI
}
